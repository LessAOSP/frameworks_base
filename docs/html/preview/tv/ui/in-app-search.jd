page.title=Searching in TV Apps
parent.title=User Interfaces for TV
parent.link=index.html

trainingnavtop=true
previous.title=DetailsFragment
previous.link=details.html
next.title=Recommendations
next.link=recommendations.html

@jd:body

<div id="qv-wrapper">
<div id="qv">
  <h2>In this document</h2>
  <ol>
    <li><a href="#add-search-ui">Add Search User Interface</a></li>
  </ol>

</div>
</div>


<p>Users frequently have specific content in mind when using a media app. A search interface can
  help your users get to the content they want faster than browsing. The Leanback library provides a
  set of classes to enable a standard search interface within your app that is consistent with other
  search functions on TV and provides features such as voice input.</p>

<h2 id="add-search-ui">Add Search User Interface</h2>
<p>When you use the BrowseFragment class for your media browsing interface, you can enable the
  search icon by setting an OnClickListener to the browse fragment object. The following sample code
  demonstrates this technique.</p>

<pre>
&#64;Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.browse_activity);

    mBrowseFragment = (BrowseFragment)
            getFragmentManager().findFragmentById(R.id.browse_fragment);

    ...

    mBrowseFragment.setOnSearchClickedListener(new View.OnClickListener() {
        &#64;Override
        public void onClick(View view) {
            Intent intent = new Intent(BrowseActivity.this, SearchActivity.class);
            startActivity(intent);
        }
    });

    mBrowseFragment.setAdapter(buildAdapter());
}
</pre>

<p class="note">
  <strong>Note:</strong> You can set the color of the search icon using the
  {@code setSearchAffordanceColor()} method of {@code BrowseFragment}.
</p>

<p>When a user selects the search icon, the system invokes a search activity via the defined
  Intent. Your search activity should use a linear layout containing a SearchFragment. This fragment
  must also implement the SearchFragment.SearchResultProvider interface in order to display the
  results of a search. The following code sample shows how to extend the SearchFragment class to
  provide a search interface and results:</p>

<pre>
public class MySearchFragment extends SearchFragment
        implements SearchFragment.SearchResultProvider {

    private static final int SEARCH_DELAY_MS = 300;
    private ArrayObjectAdapter mRowsAdapter;
    private Handler mHandler = new Handler();
    private SearchRunnable mDelayedLoad;

    &#64;Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mRowsAdapter = new ArrayObjectAdapter(new ListRowPresenter());
        setSearchResultProvider(this);
        setOnItemClickedListener(getDefaultItemClickedListener());
        mDelayedLoad = new SearchRunnable();
    }

    &#64;Override
    public ObjectAdapter getResultsAdapter() {
        return mRowsAdapter;
    }

    &#64;Override
    public boolean onQueryTextChange(String newQuery) {
        mRowsAdapter.clear();
        if (!TextUtils.isEmpty(newQuery)) {
            mDelayedLoad.setSearchQuery(newQuery);
            mHandler.removeCallbacks(mDelayedLoad);
            mHandler.postDelayed(mDelayedLoad, SEARCH_DELAY_MS);
        }
        return true;
    }

    &#64;Override
    public boolean onQueryTextSubmit(String query) {
        mRowsAdapter.clear();
        if (!TextUtils.isEmpty(query)) {
            mDelayedLoad.setSearchQuery(query);
            mHandler.removeCallbacks(mDelayedLoad);
            mHandler.postDelayed(mDelayedLoad, SEARCH_DELAY_MS);
        }
        return true;
    }
}
</pre>

<p>This example code shown above is meant to be used with a separate SearchRunnable class, that
  runs the search query on a separate thread. This technique keeps potentially slow-running queries
  from interfering with the main user interface thread.</p>

