// auto generated by generate_api_cpp.py

#include  "src/header.h"

template<typename T> static int ToInt(const T & t) { STATIC_ASSERT(sizeof(T) == sizeof(int), bitcast); return (int &)t; }

template<typename T> static T FromInt(const int & t) { STATIC_ASSERT(sizeof(T) == sizeof(int), bitcast); return (T &)t; }

void Debug_glActiveTexture(GLenum texture)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glActiveTexture);
	msg.set_arg0(texture);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glActiveTexture(texture);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glActiveTexture);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glAttachShader(GLuint program, GLuint shader)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glAttachShader);
	msg.set_arg0(program);
	msg.set_arg1(shader);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glAttachShader(program, shader);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glAttachShader);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBindAttribLocation(GLuint program, GLuint index, const GLchar* name)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBindAttribLocation);
	msg.set_arg0(program);
	msg.set_arg1(index);
	msg.set_arg2(ToInt(name));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(strlen(name) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(name)); i++)
				data.append((const char *)(name + i), sizeof(*name));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBindAttribLocation(program, index, name);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBindAttribLocation);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBindBuffer(GLenum target, GLuint buffer)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBindBuffer);
	msg.set_arg0(target);
	msg.set_arg1(buffer);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBindBuffer(target, buffer);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBindBuffer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBindFramebuffer);
	msg.set_arg0(target);
	msg.set_arg1(framebuffer);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBindFramebuffer(target, framebuffer);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBindFramebuffer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBindRenderbuffer);
	msg.set_arg0(target);
	msg.set_arg1(renderbuffer);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBindRenderbuffer(target, renderbuffer);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBindRenderbuffer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBindTexture(GLenum target, GLuint texture)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBindTexture);
	msg.set_arg0(target);
	msg.set_arg1(texture);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBindTexture(target, texture);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBindTexture);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBlendColor);
	msg.set_arg0(ToInt(red));
	msg.set_arg1(ToInt(green));
	msg.set_arg2(ToInt(blue));
	msg.set_arg3(ToInt(alpha));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBlendColor(red, green, blue, alpha);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBlendColor);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBlendEquation( GLenum mode )
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBlendEquation);
	msg.set_arg0(mode);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBlendEquation(mode);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBlendEquation);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBlendEquationSeparate);
	msg.set_arg0(modeRGB);
	msg.set_arg1(modeAlpha);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBlendEquationSeparate(modeRGB, modeAlpha);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBlendEquationSeparate);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBlendFunc);
	msg.set_arg0(sfactor);
	msg.set_arg1(dfactor);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBlendFunc(sfactor, dfactor);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBlendFunc);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBlendFuncSeparate);
	msg.set_arg0(srcRGB);
	msg.set_arg1(dstRGB);
	msg.set_arg2(srcAlpha);
	msg.set_arg3(dstAlpha);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBlendFuncSeparate);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBufferData);
	msg.set_arg0(target);
	msg.set_arg1(size);
	msg.set_arg2(ToInt(data));
	msg.set_arg3(usage);
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBufferData(target, size, data, usage);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBufferData);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glBufferSubData);
	msg.set_arg0(target);
	msg.set_arg1(offset);
	msg.set_arg2(size);
	msg.set_arg3(ToInt(data));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glBufferSubData(target, offset, size, data);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glBufferSubData);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLenum Debug_glCheckFramebufferStatus(GLenum target)
{
	GLenum ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCheckFramebufferStatus);
	msg.set_arg0(target);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glCheckFramebufferStatus(target);
			msg.set_ret(ToInt(ret));
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCheckFramebufferStatus);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = FromInt<GLenum>(cmd.ret());
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glClear(GLbitfield mask)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glClear);
	msg.set_arg0(mask);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glClear(mask);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glClear);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glClearColor);
	msg.set_arg0(ToInt(red));
	msg.set_arg1(ToInt(green));
	msg.set_arg2(ToInt(blue));
	msg.set_arg3(ToInt(alpha));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glClearColor(red, green, blue, alpha);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glClearColor);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glClearDepthf(GLclampf depth)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glClearDepthf);
	msg.set_arg0(ToInt(depth));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glClearDepthf(depth);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glClearDepthf);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glClearStencil(GLint s)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glClearStencil);
	msg.set_arg0(s);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glClearStencil(s);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glClearStencil);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glColorMask);
	msg.set_arg0(red);
	msg.set_arg1(green);
	msg.set_arg2(blue);
	msg.set_arg3(alpha);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glColorMask(red, green, blue, alpha);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glColorMask);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glCompileShader(GLuint shader)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCompileShader);
	msg.set_arg0(shader);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glCompileShader(shader);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCompileShader);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCompressedTexImage2D);
	msg.set_arg0(target);
	msg.set_arg1(level);
	msg.set_arg2(internalformat);
	msg.set_arg3(width);
	msg.set_arg4(height);
	msg.set_arg5(border);
	msg.set_arg6(imageSize);
	msg.set_arg7(ToInt(data));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCompressedTexImage2D);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCompressedTexSubImage2D);
	msg.set_arg0(target);
	msg.set_arg1(level);
	msg.set_arg2(xoffset);
	msg.set_arg3(yoffset);
	msg.set_arg4(width);
	msg.set_arg5(height);
	msg.set_arg6(format);
	msg.set_arg7(imageSize);
	msg.set_arg8(ToInt(data));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCompressedTexSubImage2D);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCopyTexImage2D);
	msg.set_arg0(target);
	msg.set_arg1(level);
	msg.set_arg2(internalformat);
	msg.set_arg3(x);
	msg.set_arg4(y);
	msg.set_arg5(width);
	msg.set_arg6(height);
	msg.set_arg7(border);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCopyTexImage2D);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCopyTexSubImage2D);
	msg.set_arg0(target);
	msg.set_arg1(level);
	msg.set_arg2(xoffset);
	msg.set_arg3(yoffset);
	msg.set_arg4(x);
	msg.set_arg5(y);
	msg.set_arg6(width);
	msg.set_arg7(height);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCopyTexSubImage2D);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLuint Debug_glCreateProgram(void)
{
	GLuint ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCreateProgram);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glCreateProgram();
			msg.set_ret(ToInt(ret));
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCreateProgram);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = FromInt<GLuint>(cmd.ret());
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLuint Debug_glCreateShader(GLenum type)
{
	GLuint ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCreateShader);
	msg.set_arg0(type);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glCreateShader(type);
			msg.set_ret(ToInt(ret));
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCreateShader);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = FromInt<GLuint>(cmd.ret());
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glCullFace(GLenum mode)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glCullFace);
	msg.set_arg0(mode);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glCullFace(mode);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glCullFace);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDeleteBuffers(GLsizei n, const GLuint* buffers)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDeleteBuffers);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(buffers));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(buffers + i), sizeof(*buffers));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDeleteBuffers(n, buffers);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDeleteBuffers);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDeleteFramebuffers);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(framebuffers));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(framebuffers + i), sizeof(*framebuffers));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDeleteFramebuffers(n, framebuffers);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDeleteFramebuffers);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDeleteProgram(GLuint program)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDeleteProgram);
	msg.set_arg0(program);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDeleteProgram(program);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDeleteProgram);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDeleteRenderbuffers);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(renderbuffers));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(renderbuffers + i), sizeof(*renderbuffers));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDeleteRenderbuffers(n, renderbuffers);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDeleteRenderbuffers);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDeleteShader(GLuint shader)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDeleteShader);
	msg.set_arg0(shader);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDeleteShader(shader);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDeleteShader);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDeleteTextures(GLsizei n, const GLuint* textures)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDeleteTextures);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(textures));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(textures + i), sizeof(*textures));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDeleteTextures(n, textures);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDeleteTextures);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDepthFunc(GLenum func)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDepthFunc);
	msg.set_arg0(func);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDepthFunc(func);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDepthFunc);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDepthMask(GLboolean flag)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDepthMask);
	msg.set_arg0(flag);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDepthMask(flag);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDepthMask);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDepthRangef(GLclampf zNear, GLclampf zFar)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDepthRangef);
	msg.set_arg0(ToInt(zNear));
	msg.set_arg1(ToInt(zFar));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDepthRangef(zNear, zFar);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDepthRangef);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDetachShader(GLuint program, GLuint shader)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDetachShader);
	msg.set_arg0(program);
	msg.set_arg1(shader);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDetachShader(program, shader);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDetachShader);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDisable(GLenum cap)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDisable);
	msg.set_arg0(cap);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDisable(cap);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDisable);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDisableVertexAttribArray(GLuint index)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDisableVertexAttribArray);
	msg.set_arg0(index);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDisableVertexAttribArray(index);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDisableVertexAttribArray);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDrawArrays);
	msg.set_arg0(mode);
	msg.set_arg1(first);
	msg.set_arg2(count);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDrawArrays(mode, first, count);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDrawArrays);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glDrawElements);
	msg.set_arg0(mode);
	msg.set_arg1(count);
	msg.set_arg2(type);
	msg.set_arg3(ToInt(indices));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glDrawElements(mode, count, type, indices);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glDrawElements);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glEnable(GLenum cap)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glEnable);
	msg.set_arg0(cap);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glEnable(cap);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glEnable);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glEnableVertexAttribArray(GLuint index)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glEnableVertexAttribArray);
	msg.set_arg0(index);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glEnableVertexAttribArray(index);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glEnableVertexAttribArray);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glFinish(void)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glFinish);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glFinish();
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glFinish);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glFlush(void)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glFlush);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glFlush();
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glFlush);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glFramebufferRenderbuffer);
	msg.set_arg0(target);
	msg.set_arg1(attachment);
	msg.set_arg2(renderbuffertarget);
	msg.set_arg3(renderbuffer);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glFramebufferRenderbuffer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glFramebufferTexture2D);
	msg.set_arg0(target);
	msg.set_arg1(attachment);
	msg.set_arg2(textarget);
	msg.set_arg3(texture);
	msg.set_arg4(level);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glFramebufferTexture2D(target, attachment, textarget, texture, level);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glFramebufferTexture2D);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glFrontFace(GLenum mode)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glFrontFace);
	msg.set_arg0(mode);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glFrontFace(mode);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glFrontFace);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glGenBuffers(GLsizei n, GLuint* buffers)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGenBuffers);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(buffers));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGenBuffers(n, buffers);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGenBuffers);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(buffers + i), sizeof(*buffers));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glGenerateMipmap(GLenum target)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGenerateMipmap);
	msg.set_arg0(target);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGenerateMipmap(target);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGenerateMipmap);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glGenFramebuffers(GLsizei n, GLuint* framebuffers)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGenFramebuffers);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(framebuffers));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGenFramebuffers(n, framebuffers);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGenFramebuffers);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(framebuffers + i), sizeof(*framebuffers));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glGenRenderbuffers(GLsizei n, GLuint* renderbuffers)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGenRenderbuffers);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(renderbuffers));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGenRenderbuffers(n, renderbuffers);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGenRenderbuffers);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(renderbuffers + i), sizeof(*renderbuffers));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glGenTextures(GLsizei n, GLuint* textures)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGenTextures);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(textures));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGenTextures(n, textures);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGenTextures);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(n * sizeof(GLuint));
			for (unsigned i = 0; i < (n); i++)
				data.append((const char *)(textures + i), sizeof(*textures));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetActiveAttrib);
	msg.set_arg0(program);
	msg.set_arg1(index);
	msg.set_arg2(bufsize);
	msg.set_arg3(ToInt(length));
	msg.set_arg4(ToInt(size));
	msg.set_arg5(ToInt(type));
	msg.set_arg6(ToInt(name));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(strlen(name) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(name)); i++)
				data.append((const char *)(name + i), sizeof(*name));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetActiveAttrib(program, index, bufsize, length, size, type, name);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetActiveAttrib);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetActiveUniform);
	msg.set_arg0(program);
	msg.set_arg1(index);
	msg.set_arg2(bufsize);
	msg.set_arg3(ToInt(length));
	msg.set_arg4(ToInt(size));
	msg.set_arg5(ToInt(type));
	msg.set_arg6(ToInt(name));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(strlen(name) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(name)); i++)
				data.append((const char *)(name + i), sizeof(*name));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetActiveUniform(program, index, bufsize, length, size, type, name);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetActiveUniform);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetAttachedShaders);
	msg.set_arg0(program);
	msg.set_arg1(maxcount);
	msg.set_arg2(ToInt(count));
	msg.set_arg3(ToInt(shaders));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetAttachedShaders(program, maxcount, count, shaders);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetAttachedShaders);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

int Debug_glGetAttribLocation(GLuint program, const GLchar* name)
{
	int ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetAttribLocation);
	msg.set_arg0(program);
	msg.set_arg1(ToInt(name));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(strlen(name) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(name)); i++)
				data.append((const char *)(name + i), sizeof(*name));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glGetAttribLocation(program, name);
			msg.set_ret(ToInt(ret));
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetAttribLocation);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = FromInt<int>(cmd.ret());
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetBooleanv(GLenum pname, GLboolean* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetBooleanv);
	msg.set_arg0(pname);
	msg.set_arg1(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetBooleanv(pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetBooleanv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetBufferParameteriv);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetBufferParameteriv(target, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetBufferParameteriv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLenum Debug_glGetError(void)
{
	GLenum ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetError);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glGetError();
			msg.set_ret(ToInt(ret));
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetError);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = FromInt<GLenum>(cmd.ret());
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetFloatv(GLenum pname, GLfloat* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetFloatv);
	msg.set_arg0(pname);
	msg.set_arg1(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetFloatv(pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetFloatv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetFramebufferAttachmentParameteriv);
	msg.set_arg0(target);
	msg.set_arg1(attachment);
	msg.set_arg2(pname);
	msg.set_arg3(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetFramebufferAttachmentParameteriv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetIntegerv(GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetIntegerv);
	msg.set_arg0(pname);
	msg.set_arg1(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetIntegerv(pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetIntegerv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glGetProgramiv(GLuint program, GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetProgramiv);
	msg.set_arg0(program);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetProgramiv(program, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetProgramiv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(1 * sizeof(GLint));
			for (unsigned i = 0; i < (1); i++)
				data.append((const char *)(params + i), sizeof(*params));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetProgramInfoLog);
	msg.set_arg0(program);
	msg.set_arg1(bufsize);
	msg.set_arg2(ToInt(length));
	msg.set_arg3(ToInt(infolog));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetProgramInfoLog(program, bufsize, length, infolog);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetProgramInfoLog);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(strlen(infolog) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(infolog)); i++)
				data.append((const char *)(infolog + i), sizeof(*infolog));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetRenderbufferParameteriv);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetRenderbufferParameteriv(target, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetRenderbufferParameteriv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetShaderiv);
	msg.set_arg0(shader);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetShaderiv(shader, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetShaderiv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(1 * sizeof(GLint));
			for (unsigned i = 0; i < (1); i++)
				data.append((const char *)(params + i), sizeof(*params));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetShaderInfoLog);
	msg.set_arg0(shader);
	msg.set_arg1(bufsize);
	msg.set_arg2(ToInt(length));
	msg.set_arg3(ToInt(infolog));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetShaderInfoLog(shader, bufsize, length, infolog);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetShaderInfoLog);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(strlen(infolog) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(infolog)); i++)
				data.append((const char *)(infolog + i), sizeof(*infolog));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetShaderPrecisionFormat);
	msg.set_arg0(shadertype);
	msg.set_arg1(precisiontype);
	msg.set_arg2(ToInt(range));
	msg.set_arg3(ToInt(precision));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetShaderPrecisionFormat);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetShaderSource);
	msg.set_arg0(shader);
	msg.set_arg1(bufsize);
	msg.set_arg2(ToInt(length));
	msg.set_arg3(ToInt(source));
	std::string data;
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetShaderSource(shader, bufsize, length, source);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetShaderSource);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			data.reserve(strlen(source) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(source)); i++)
				data.append((const char *)(source + i), sizeof(*source));
			msg.set_data(data);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
const GLubyte* Debug_glGetString(GLenum name)
{
	const GLubyte* ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetString);
	msg.set_arg0(name);
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glGetString(name);
			msg.set_ret(ToInt(ret));
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetString);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = FromInt<const GLubyte*>(cmd.ret());
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetTexParameterfv);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetTexParameterfv(target, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetTexParameterfv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetTexParameteriv(GLenum target, GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetTexParameteriv);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetTexParameteriv(target, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetTexParameteriv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetUniformfv(GLuint program, GLint location, GLfloat* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetUniformfv);
	msg.set_arg0(program);
	msg.set_arg1(location);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetUniformfv(program, location, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetUniformfv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetUniformiv(GLuint program, GLint location, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetUniformiv);
	msg.set_arg0(program);
	msg.set_arg1(location);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetUniformiv(program, location, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetUniformiv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

int Debug_glGetUniformLocation(GLuint program, const GLchar* name)
{
	int ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetUniformLocation);
	msg.set_arg0(program);
	msg.set_arg1(ToInt(name));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(strlen(name) * sizeof(GLchar));
			for (unsigned i = 0; i < (strlen(name)); i++)
				data.append((const char *)(name + i), sizeof(*name));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glGetUniformLocation(program, name);
			msg.set_ret(ToInt(ret));
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetUniformLocation);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = FromInt<int>(cmd.ret());
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetVertexAttribfv);
	msg.set_arg0(index);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetVertexAttribfv(index, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetVertexAttribfv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetVertexAttribiv);
	msg.set_arg0(index);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetVertexAttribiv(index, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetVertexAttribiv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glGetVertexAttribPointerv);
	msg.set_arg0(index);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(pointer));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glGetVertexAttribPointerv(index, pname, pointer);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glGetVertexAttribPointerv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glHint(GLenum target, GLenum mode)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glHint);
	msg.set_arg0(target);
	msg.set_arg1(mode);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glHint(target, mode);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glHint);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLboolean Debug_glIsBuffer(GLuint buffer)
{
	GLboolean ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glIsBuffer);
	msg.set_arg0(buffer);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glIsBuffer(buffer);
			msg.set_ret(ret);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glIsBuffer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = cmd.ret();
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLboolean Debug_glIsEnabled(GLenum cap)
{
	GLboolean ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glIsEnabled);
	msg.set_arg0(cap);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glIsEnabled(cap);
			msg.set_ret(ret);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glIsEnabled);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = cmd.ret();
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLboolean Debug_glIsFramebuffer(GLuint framebuffer)
{
	GLboolean ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glIsFramebuffer);
	msg.set_arg0(framebuffer);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glIsFramebuffer(framebuffer);
			msg.set_ret(ret);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glIsFramebuffer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = cmd.ret();
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLboolean Debug_glIsProgram(GLuint program)
{
	GLboolean ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glIsProgram);
	msg.set_arg0(program);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glIsProgram(program);
			msg.set_ret(ret);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glIsProgram);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = cmd.ret();
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLboolean Debug_glIsRenderbuffer(GLuint renderbuffer)
{
	GLboolean ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glIsRenderbuffer);
	msg.set_arg0(renderbuffer);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glIsRenderbuffer(renderbuffer);
			msg.set_ret(ret);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glIsRenderbuffer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = cmd.ret();
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLboolean Debug_glIsShader(GLuint shader)
{
	GLboolean ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glIsShader);
	msg.set_arg0(shader);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glIsShader(shader);
			msg.set_ret(ret);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glIsShader);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = cmd.ret();
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

GLboolean Debug_glIsTexture(GLuint texture)
{
	GLboolean ret = 0;
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glIsTexture);
	msg.set_arg0(texture);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			ret = _c->glIsTexture(texture);
			msg.set_ret(ret);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glIsTexture);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			if (cmd.has_ret())
				ret = cmd.ret();
			return ret;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glLineWidth(GLfloat width)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glLineWidth);
	msg.set_arg0(ToInt(width));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glLineWidth(width);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glLineWidth);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glLinkProgram(GLuint program)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glLinkProgram);
	msg.set_arg0(program);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glLinkProgram(program);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glLinkProgram);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glPixelStorei(GLenum pname, GLint param)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glPixelStorei);
	msg.set_arg0(pname);
	msg.set_arg1(param);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glPixelStorei(pname, param);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glPixelStorei);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glPolygonOffset(GLfloat factor, GLfloat units)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glPolygonOffset);
	msg.set_arg0(ToInt(factor));
	msg.set_arg1(ToInt(units));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glPolygonOffset(factor, units);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glPolygonOffset);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glReadPixels);
	msg.set_arg0(x);
	msg.set_arg1(y);
	msg.set_arg2(width);
	msg.set_arg3(height);
	msg.set_arg4(format);
	msg.set_arg5(type);
	msg.set_arg6(ToInt(pixels));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glReadPixels(x, y, width, height, format, type, pixels);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glReadPixels);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glReleaseShaderCompiler(void)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glReleaseShaderCompiler);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glReleaseShaderCompiler();
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glReleaseShaderCompiler);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glRenderbufferStorage);
	msg.set_arg0(target);
	msg.set_arg1(internalformat);
	msg.set_arg2(width);
	msg.set_arg3(height);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glRenderbufferStorage(target, internalformat, width, height);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glRenderbufferStorage);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glSampleCoverage(GLclampf value, GLboolean invert)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glSampleCoverage);
	msg.set_arg0(ToInt(value));
	msg.set_arg1(invert);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glSampleCoverage(value, invert);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glSampleCoverage);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glScissor);
	msg.set_arg0(x);
	msg.set_arg1(y);
	msg.set_arg2(width);
	msg.set_arg3(height);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glScissor(x, y, width, height);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glScissor);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const GLvoid* binary, GLsizei length)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glShaderBinary);
	msg.set_arg0(n);
	msg.set_arg1(ToInt(shaders));
	msg.set_arg2(binaryformat);
	msg.set_arg3(ToInt(binary));
	msg.set_arg4(length);
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glShaderBinary(n, shaders, binaryformat, binary, length);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glShaderBinary);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glStencilFunc);
	msg.set_arg0(func);
	msg.set_arg1(ref);
	msg.set_arg2(mask);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glStencilFunc(func, ref, mask);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glStencilFunc);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glStencilFuncSeparate);
	msg.set_arg0(face);
	msg.set_arg1(func);
	msg.set_arg2(ref);
	msg.set_arg3(mask);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glStencilFuncSeparate(face, func, ref, mask);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glStencilFuncSeparate);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glStencilMask(GLuint mask)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glStencilMask);
	msg.set_arg0(mask);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glStencilMask(mask);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glStencilMask);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glStencilMaskSeparate(GLenum face, GLuint mask)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glStencilMaskSeparate);
	msg.set_arg0(face);
	msg.set_arg1(mask);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glStencilMaskSeparate(face, mask);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glStencilMaskSeparate);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glStencilOp);
	msg.set_arg0(fail);
	msg.set_arg1(zfail);
	msg.set_arg2(zpass);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glStencilOp(fail, zfail, zpass);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glStencilOp);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glStencilOpSeparate);
	msg.set_arg0(face);
	msg.set_arg1(fail);
	msg.set_arg2(zfail);
	msg.set_arg3(zpass);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glStencilOpSeparate(face, fail, zfail, zpass);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glStencilOpSeparate);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glTexParameterf);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(param));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glTexParameterf(target, pname, param);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glTexParameterf);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glTexParameterfv);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glTexParameterfv(target, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glTexParameterfv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glTexParameteri);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(param);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glTexParameteri(target, pname, param);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glTexParameteri);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glTexParameteriv(GLenum target, GLenum pname, const GLint* params)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glTexParameteriv);
	msg.set_arg0(target);
	msg.set_arg1(pname);
	msg.set_arg2(ToInt(params));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glTexParameteriv(target, pname, params);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glTexParameteriv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform1f(GLint location, GLfloat x)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform1f);
	msg.set_arg0(location);
	msg.set_arg1(ToInt(x));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform1f(location, x);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform1f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform1fv(GLint location, GLsizei count, const GLfloat* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform1fv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(1*count * sizeof(GLfloat));
			for (unsigned i = 0; i < (1*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform1fv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform1fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform1i(GLint location, GLint x)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform1i);
	msg.set_arg0(location);
	msg.set_arg1(x);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform1i(location, x);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform1i);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform1iv(GLint location, GLsizei count, const GLint* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform1iv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(1*count * sizeof(GLint));
			for (unsigned i = 0; i < (1*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform1iv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform1iv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform2f(GLint location, GLfloat x, GLfloat y)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform2f);
	msg.set_arg0(location);
	msg.set_arg1(ToInt(x));
	msg.set_arg2(ToInt(y));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform2f(location, x, y);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform2f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform2fv(GLint location, GLsizei count, const GLfloat* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform2fv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(2*count * sizeof(GLfloat));
			for (unsigned i = 0; i < (2*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform2fv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform2fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform2i(GLint location, GLint x, GLint y)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform2i);
	msg.set_arg0(location);
	msg.set_arg1(x);
	msg.set_arg2(y);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform2i(location, x, y);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform2i);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform2iv(GLint location, GLsizei count, const GLint* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform2iv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(2*count * sizeof(GLint));
			for (unsigned i = 0; i < (2*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform2iv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform2iv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform3f);
	msg.set_arg0(location);
	msg.set_arg1(ToInt(x));
	msg.set_arg2(ToInt(y));
	msg.set_arg3(ToInt(z));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform3f(location, x, y, z);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform3f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform3fv(GLint location, GLsizei count, const GLfloat* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform3fv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(3*count * sizeof(GLfloat));
			for (unsigned i = 0; i < (3*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform3fv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform3fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform3i(GLint location, GLint x, GLint y, GLint z)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform3i);
	msg.set_arg0(location);
	msg.set_arg1(x);
	msg.set_arg2(y);
	msg.set_arg3(z);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform3i(location, x, y, z);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform3i);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform3iv(GLint location, GLsizei count, const GLint* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform3iv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(3*count * sizeof(GLint));
			for (unsigned i = 0; i < (3*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform3iv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform3iv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform4f);
	msg.set_arg0(location);
	msg.set_arg1(ToInt(x));
	msg.set_arg2(ToInt(y));
	msg.set_arg3(ToInt(z));
	msg.set_arg4(ToInt(w));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform4f(location, x, y, z, w);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform4f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform4fv(GLint location, GLsizei count, const GLfloat* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform4fv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(4*count * sizeof(GLfloat));
			for (unsigned i = 0; i < (4*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform4fv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform4fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform4i);
	msg.set_arg0(location);
	msg.set_arg1(x);
	msg.set_arg2(y);
	msg.set_arg3(z);
	msg.set_arg4(w);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform4i(location, x, y, z, w);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform4i);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniform4iv(GLint location, GLsizei count, const GLint* v)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniform4iv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(ToInt(v));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(4*count * sizeof(GLint));
			for (unsigned i = 0; i < (4*count); i++)
				data.append((const char *)(v + i), sizeof(*v));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniform4iv(location, count, v);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniform4iv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniformMatrix2fv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(transpose);
	msg.set_arg3(ToInt(value));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(4*count * sizeof(GLfloat));
			for (unsigned i = 0; i < (4*count); i++)
				data.append((const char *)(value + i), sizeof(*value));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniformMatrix2fv(location, count, transpose, value);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniformMatrix2fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniformMatrix3fv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(transpose);
	msg.set_arg3(ToInt(value));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(9*count * sizeof(GLfloat));
			for (unsigned i = 0; i < (9*count); i++)
				data.append((const char *)(value + i), sizeof(*value));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniformMatrix3fv(location, count, transpose, value);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniformMatrix3fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUniformMatrix4fv);
	msg.set_arg0(location);
	msg.set_arg1(count);
	msg.set_arg2(transpose);
	msg.set_arg3(ToInt(value));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(16*count * sizeof(GLfloat));
			for (unsigned i = 0; i < (16*count); i++)
				data.append((const char *)(value + i), sizeof(*value));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUniformMatrix4fv(location, count, transpose, value);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUniformMatrix4fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glUseProgram(GLuint program)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glUseProgram);
	msg.set_arg0(program);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glUseProgram(program);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glUseProgram);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glValidateProgram(GLuint program)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glValidateProgram);
	msg.set_arg0(program);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glValidateProgram(program);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glValidateProgram);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib1f(GLuint indx, GLfloat x)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib1f);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(x));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib1f(indx, x);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib1f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib1fv(GLuint indx, const GLfloat* values)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib1fv);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(values));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(1 * sizeof(GLfloat));
			for (unsigned i = 0; i < (1); i++)
				data.append((const char *)(values + i), sizeof(*values));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib1fv(indx, values);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib1fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib2f);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(x));
	msg.set_arg2(ToInt(y));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib2f(indx, x, y);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib2f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib2fv(GLuint indx, const GLfloat* values)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib2fv);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(values));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(2 * sizeof(GLfloat));
			for (unsigned i = 0; i < (2); i++)
				data.append((const char *)(values + i), sizeof(*values));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib2fv(indx, values);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib2fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib3f);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(x));
	msg.set_arg2(ToInt(y));
	msg.set_arg3(ToInt(z));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib3f(indx, x, y, z);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib3f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib3fv(GLuint indx, const GLfloat* values)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib3fv);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(values));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(3 * sizeof(GLfloat));
			for (unsigned i = 0; i < (3); i++)
				data.append((const char *)(values + i), sizeof(*values));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib3fv(indx, values);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib3fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib4f);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(x));
	msg.set_arg2(ToInt(y));
	msg.set_arg3(ToInt(z));
	msg.set_arg4(ToInt(w));
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib4f(indx, x, y, z, w);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib4f);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glVertexAttrib4fv(GLuint indx, const GLfloat* values)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib4fv);
	msg.set_arg0(indx);
	msg.set_arg1(ToInt(values));
	std::string data;
	// FIXME: check for pointer usage
			data.reserve(4 * sizeof(GLfloat));
			for (unsigned i = 0; i < (4); i++)
				data.append((const char *)(values + i), sizeof(*values));
			msg.set_data(data);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttrib4fv(indx, values);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttrib4fv);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: this function has pointers, it should be hand written
void Debug_glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glVertexAttribPointer);
	msg.set_arg0(indx);
	msg.set_arg1(size);
	msg.set_arg2(type);
	msg.set_arg3(normalized);
	msg.set_arg4(stride);
	msg.set_arg5(ToInt(ptr));
	// FIXME: check for pointer usage
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glVertexAttribPointer);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

void Debug_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	gl_hooks_t::gl_t const * const _c = &getGLTraceThreadSpecific()->gl;
	GLESv2Debugger::Message msg, cmd;
	msg.set_context_id(0);
	msg.set_has_next_message(true);
	const bool expectResponse = false;
	msg.set_expect_response(expectResponse);
	msg.set_function(GLESv2Debugger::Message_Function_glViewport);
	msg.set_arg0(x);
	msg.set_arg1(y);
	msg.set_arg2(width);
	msg.set_arg3(height);
	Send(msg, cmd);
	if (!expectResponse)
		cmd.set_function(GLESv2Debugger::Message_Function_CONTINUE);
	while (true) {
		msg.Clear();
		clock_t c0 = clock();
		switch (cmd.function()) {
		case GLESv2Debugger::Message_Function_CONTINUE:
			_c->glViewport(x, y, width, height);
			msg.set_time((float(clock()) - c0) / CLOCKS_PER_SEC);
			msg.set_context_id(0);
			msg.set_function(GLESv2Debugger::Message_Function_glViewport);
			msg.set_has_next_message(false);
			msg.set_expect_response(expectResponse);
			Send(msg, cmd);
			if (!expectResponse)
				cmd.set_function(GLESv2Debugger::Message_Function_SKIP);
			break;
		case GLESv2Debugger::Message_Function_SKIP:
			return;
		default:
			ASSERT(0); //GenerateCall(msg, cmd); 
			break;
		}
	}
}

// FIXME: the following functions should be written by hand
void Debug_glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);
void Debug_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
void Debug_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data);
void Debug_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data);
void Debug_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices);
void Debug_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
void Debug_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
void Debug_glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);
void Debug_glGetBooleanv(GLenum pname, GLboolean* params);
void Debug_glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params);
void Debug_glGetFloatv(GLenum pname, GLfloat* params);
void Debug_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params);
void Debug_glGetIntegerv(GLenum pname, GLint* params);
void Debug_glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog);
void Debug_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params);
void Debug_glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog);
void Debug_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
void Debug_glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
const GLubyte* Debug_glGetString(GLenum name);
void Debug_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params);
void Debug_glGetTexParameteriv(GLenum target, GLenum pname, GLint* params);
void Debug_glGetUniformfv(GLuint program, GLint location, GLfloat* params);
void Debug_glGetUniformiv(GLuint program, GLint location, GLint* params);
void Debug_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params);
void Debug_glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params);
void Debug_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer);
void Debug_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);
void Debug_glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const GLvoid* binary, GLsizei length);
void Debug_glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params);
void Debug_glTexParameteriv(GLenum target, GLenum pname, const GLint* params);
void Debug_glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr);
